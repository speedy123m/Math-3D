<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Math 3D Teacher Tool — Edges & RGB</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #222; user-select: none; }
    #canvas-container { width: 100vw; height: 100vh; display: block; position: relative; }

    /* UI Panel Styling */
    #ui-panel {
      position: absolute; top: 20px; right: 20px;
      background: rgba(255,255,255,0.95); padding: 12px; border-radius: 12px;
      display:flex; flex-direction:column; gap:8px; width:170px; z-index:20;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .panel-section { border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 8px; }
    .panel-section:last-child { border-bottom: none; margin-bottom: 0; }
    .label { font-size:11px; color:#666; font-weight:700; text-transform:uppercase; margin-bottom:6px; letter-spacing:0.5px; }

    /* Buttons */
    button {
      width: 100%; background:#007bff; color:#fff; border:none; padding:9px;
      border-radius:6px; font-weight:600; cursor:pointer; font-size:14px;
      margin-bottom: 6px; touch-action: none; /* Critical for Smartboards */
    }
    button:active { transform: scale(0.98); }
    button.secondary { background: #6c757d; font-size: 13px; }
    button.danger { background: #dc3545; }

    /* Small controls row (RGB inputs) */
    .row { display:flex; gap:6px; align-items:center; }
    .row input[type="number"] {
      width: 44px; padding:6px; border-radius:6px; border:1px solid #ccc; font-weight:600;
    }
    .tiny { font-size:12px; color:#444; }

    /* Help Text Overlay */
    #overlay {
      position:absolute; bottom:20px; left:20px; pointer-events:none; color:rgba(255,255,255,0.8);
      font-size: 14px; background: rgba(0,0,0,0.45); padding: 8px 10px; border-radius: 8px;
    }

    /* Make sure canvas won't let OS intercept gestures */
    #canvas-container canvas { touch-action: none; -ms-touch-action: none; }
  </style>

  <!-- Use legacy r128 non-module Three + OrbitControls for compatibility -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<div id="canvas-container"></div>

<div id="ui-panel">
  <div class="panel-section">
    <div class="label">Add Shape</div>
    <button onclick="addShape('cylinder')">Cylinder</button>
    <button onclick="addShape('cube')">Cube</button>
    <button onclick="addShape('sphere')">Sphere</button>
    <button onclick="addShape('cone')">Cone</button>
  </div>

  <div class="panel-section">
    <div class="label">Teach Tools</div>
    <button id="toggle-edges-btn" class="secondary" onclick="toggleEdges()">Show Edges (Selected)</button>
    <div style="height:6px"></div>
    <div class="tiny">RGB (0–255)</div>
    <div class="row">
      <input id="r-input" type="number" min="0" max="255" value="77" />
      <input id="g-input" type="number" min="0" max="255" value="171" />
      <input id="b-input" type="number" min="0" max="255" value="247" />
    </div>
    <button onclick="applyRGB()" style="margin-top:6px">Apply Color</button>
  </div>

  <div>
    <button class="danger" id="delete-btn" onclick="deleteSelected()">Delete</button>
  </div>
</div>

<div id="overlay">
  Tap shape to Select • Drag to Move • Pinch to Zoom • Two-finger drag to Pan
</div>

<script>
(function(){
  // Core three objects
  let scene, camera, renderer, controls;
  let raycaster, mouse;
  let selectedObject = null;
  let isDragging = false;

  // Camera fallback state
  let isCameraDragging = false;
  let prevX = 0, prevY = 0;

  // Multi-pointer tracking for pointer events
  const activePointers = {}; // id -> {x,y}
  let isPointerPinching = false;

  // Touch pinch fallback
  let isTouchPinching = false;
  let touchStartDist = 0;
  let pinchStartRadius = 0;
  const pinchStartMid = { x:0, y:0 };

  // Camera target
  const cameraTarget = new THREE.Vector3(0, 1, 0);

  // Drag plane for moving shapes
  const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
  const intersectPoint = new THREE.Vector3();

  // Spherical used for camera manual transforms
  let spherical = new THREE.Spherical();
  const minDistance = 1.2;
  const maxDistance = 100;

  // Edge toggle state
  let showEdgesEnabled = false;

  // Wait for DOM
  window.addEventListener('load', () => { init(); animate(); });

  function init() {
    const container = document.getElementById('canvas-container');

    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    // Camera
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(5, 5, 8);
    camera.lookAt(cameraTarget);

    // initialize spherical from camera pos
    updateSphericalFromCamera();

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.shadowMap.enabled = true;
    renderer.domElement.style.touchAction = 'none';
    container.appendChild(renderer.domElement);

    // Lights & grid
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 12, 5);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const grid = new THREE.GridHelper(20, 20);
    scene.add(grid);

    // OrbitControls (legacy)
    if (typeof THREE.OrbitControls === 'function') {
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = true;
      controls.enablePan = true;
      controls.enableRotate = true;
      controls.screenSpacePanning = false;
      controls.maxPolarAngle = Math.PI / 2;
      controls.minDistance = minDistance;
      controls.maxDistance = maxDistance;
      controls.target.copy(cameraTarget);

      if ('ontouchstart' in window) {
        controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
      }
    }

    // Interaction
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    const canvas = renderer.domElement;

    // Pointer / touch / mouse listeners
    if (window.PointerEvent) {
      canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
      window.addEventListener('pointermove', onPointerMove, { passive: false });
      window.addEventListener('pointerup', onPointerUp, { passive: false });
      canvas.addEventListener('pointercancel', onPointerUp, { passive: false });
    } else {
      // Touch fallback
      canvas.addEventListener('touchstart', onTouchStart, { passive: false });
      window.addEventListener('touchmove', onTouchMove, { passive: false });
      window.addEventListener('touchend', onTouchEnd, false);

      // Mouse fallback
      canvas.addEventListener('mousedown', onMouseDown, false);
      window.addEventListener('mousemove', onMouseMove, false);
      window.addEventListener('mouseup', onMouseUp, false);
    }

    window.addEventListener('resize', onWindowResize, false);
  }

  // ---------- Camera helpers ----------
  function updateSphericalFromCamera() {
    const offset = camera.position.clone().sub(cameraTarget);
    spherical.setFromVector3(offset);
    spherical.radius = Math.max(minDistance, Math.min(maxDistance, spherical.radius));
  }
  function applySpherical() {
    const offset = new THREE.Vector3();
    offset.setFromSpherical(spherical);
    camera.position.copy(cameraTarget).add(offset);
    camera.lookAt(cameraTarget);
    if (controls) { controls.target.copy(cameraTarget); controls.update(); }
  }
  function manualCameraRotate(dx, dy) {
    const rotSpeed = 0.005;
    spherical.theta -= dx * rotSpeed;
    spherical.phi -= dy * rotSpeed;
    spherical.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.05, spherical.phi));
    applySpherical();
  }
  function manualCameraDollyByScale(scale) {
    spherical.radius = Math.max(minDistance, Math.min(maxDistance, pinchStartRadius * scale));
    applySpherical();
  }
  function manualCameraPanWorld(dx, dy) {
    const panSpeed = spherical.radius * 0.002;
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    const right = new THREE.Vector3().crossVectors(camera.up, camDir).normalize();
    const up = new THREE.Vector3().copy(camera.up).normalize();

    const pan = new THREE.Vector3();
    pan.addScaledVector(right, -dx * panSpeed);
    pan.addScaledVector(up, dy * panSpeed);

    cameraTarget.add(pan);
    camera.position.add(pan);
    if (controls) { controls.target.copy(cameraTarget); controls.update(); } else { camera.lookAt(cameraTarget); }
  }

  // ---------- Pointer helpers ----------
  function pointerDistanceBetweenTwo() {
    const ids = Object.keys(activePointers);
    if (ids.length < 2) return 0;
    const a = activePointers[ids[0]];
    const b = activePointers[ids[1]];
    return Math.hypot(a.x - b.x, a.y - b.y);
  }
  function pointerMidpoint() {
    const ids = Object.keys(activePointers);
    const a = activePointers[ids[0]];
    const b = activePointers[ids[1]];
    return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
  }

  // ---------- Input helpers ----------
  function getCanvasCoords(clientX, clientY) {
    const rect = renderer.domElement.getBoundingClientRect();
    return { x: ((clientX - rect.left) / rect.width) * 2 - 1, y: -((clientY - rect.top) / rect.height) * 2 + 1 };
  }

  function handleInputStart(x, y) {
    const coords = getCanvasCoords(x, y);
    mouse.x = coords.x; mouse.y = coords.y;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    const hit = intersects.find(i => {
      const obj = i.object;
      const isShape = obj.userData && obj.userData.isShape;
      const parentIsShape = obj.parent && obj.parent.userData && obj.parent.userData.isShape;
      return isShape || parentIsShape;
    });

    if (hit) {
      const target = (hit.object.userData && hit.object.userData.isShape) ? hit.object : hit.object.parent;
      selectObject(target);
      isDragging = true;
      return true;
    } else {
      if (selectedObject) { setEmissive(selectedObject, 0x000000); selectedObject = null; document.getElementById('delete-btn').innerText = "Delete"; }
      isDragging = false;
      return false;
    }
  }

  function handleInputMove(x, y) {
    if (!isDragging || !selectedObject) return;
    const coords = getCanvasCoords(x, y);
    mouse.x = coords.x; mouse.y = coords.y;
    raycaster.setFromCamera(mouse, camera);
    if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
      selectedObject.position.x = intersectPoint.x;
      selectedObject.position.z = intersectPoint.z;
    }
  }

  function handleInputEnd() {
    isDragging = false;
  }

  // ---------- Pointer events ----------
  function onPointerDown(e) {
    activePointers[e.pointerId] = { x: e.clientX, y: e.clientY };
    if (e.target && e.target.closest && e.target.closest('#ui-panel')) return;

    const count = Object.keys(activePointers).length;
    if (count === 2) {
      isPointerPinching = true;
      const dist = pointerDistanceBetweenTwo();
      touchStartDist = dist;
      pinchStartRadius = spherical.radius;
      const mid = pointerMidpoint();
      pinchStartMid.x = mid.x; pinchStartMid.y = mid.y;
      if (controls) controls.enabled = false;
      e.preventDefault();
      return;
    }

    if (handleInputStart(e.clientX, e.clientY)) {
      if (controls) controls.enabled = false;
      e.preventDefault(); e.stopPropagation();
      return;
    } else {
      isCameraDragging = true;
      prevX = e.clientX; prevY = e.clientY;
      if (controls) controls.enabled = false;
      e.preventDefault();
    }
  }

  function onPointerMove(e) {
    if (activePointers[e.pointerId]) activePointers[e.pointerId].x = e.clientX, activePointers[e.pointerId].y = e.clientY;

    if (isPointerPinching && Object.keys(activePointers).length >= 2) {
      const dist = pointerDistanceBetweenTwo();
      if (touchStartDist > 0) {
        const scale = touchStartDist / dist;
        spherical.radius = Math.max(minDistance, Math.min(maxDistance, pinchStartRadius * scale));
        applySpherical();
      }
      const mid = pointerMidpoint();
      const dx = mid.x - pinchStartMid.x;
      const dy = mid.y - pinchStartMid.y;
      manualCameraPanWorld(dx, dy);
      pinchStartMid.x = mid.x; pinchStartMid.y = mid.y;
      return;
    }

    if (isDragging && selectedObject) {
      e.preventDefault();
      handleInputMove(e.clientX, e.clientY);
      return;
    }

    if (isCameraDragging) {
      e.preventDefault();
      const dx = e.clientX - prevX;
      const dy = e.clientY - prevY;
      manualCameraRotate(dx, dy);
      prevX = e.clientX; prevY = e.clientY;
      return;
    }
  }

  function onPointerUp(e) {
    delete activePointers[e.pointerId];

    if (isPointerPinching && Object.keys(activePointers).length < 2) {
      isPointerPinching = false;
      touchStartDist = 0;
      pinchStartRadius = spherical.radius;
      if (controls) controls.enabled = true;
    }

    if (isDragging) handleInputEnd();
    isCameraDragging = false;
    if (controls && Object.keys(activePointers).length === 0) controls.enabled = true;
  }

  // ---------- Touch fallback ----------
  function getTouchDist(t0, t1) { return Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY); }
  function getTouchMid(t0, t1) { return { x: (t0.clientX + t1.clientX)/2, y: (t0.clientY + t1.clientY)/2 }; }

  function onTouchStart(e) {
    if (e.touches.length === 2) {
      isTouchPinching = true;
      touchStartDist = getTouchDist(e.touches[0], e.touches[1]);
      pinchStartRadius = spherical.radius;
      const mid = getTouchMid(e.touches[0], e.touches[1]);
      pinchStartMid.x = mid.x; pinchStartMid.y = mid.y;
      if (controls) controls.enabled = false;
      e.preventDefault(); return;
    }
    if (e.touches.length === 1) {
      if (e.target && e.target.closest && e.target.closest('#ui-panel')) return;
      if (handleInputStart(e.touches[0].clientX, e.touches[0].clientY)) {
        if (controls) controls.enabled = false;
        e.preventDefault();
      } else {
        isCameraDragging = true;
        prevX = e.touches[0].clientX; prevY = e.touches[0].clientY;
        if (controls) controls.enabled = false;
        e.preventDefault();
      }
    }
  }

  function onTouchMove(e) {
    if (isTouchPinching && e.touches.length === 2) {
      const dist = getTouchDist(e.touches[0], e.touches[1]);
      const scale = touchStartDist / dist;
      spherical.radius = Math.max(minDistance, Math.min(maxDistance, pinchStartRadius * scale));
      applySpherical();
      const mid = getTouchMid(e.touches[0], e.touches[1]);
      const dx = mid.x - pinchStartMid.x;
      const dy = mid.y - pinchStartMid.y;
      manualCameraPanWorld(dx, dy);
      pinchStartMid.x = mid.x; pinchStartMid.y = mid.y;
      e.preventDefault(); return;
    }

    if (isDragging && e.touches.length === 1 && selectedObject) {
      e.preventDefault();
      handleInputMove(e.touches[0].clientX, e.touches[0].clientY); return;
    }

    if (isCameraDragging && e.touches.length === 1) {
      e.preventDefault();
      const dx = e.touches[0].clientX - prevX;
      const dy = e.touches[0].clientY - prevY;
      manualCameraRotate(dx, dy);
      prevX = e.touches[0].clientX; prevY = e.touches[0].clientY; return;
    }
  }

  function onTouchEnd(e) {
    if (isTouchPinching && e.touches.length < 2) {
      isTouchPinching = false;
      pinchStartRadius = spherical.radius;
      if (controls) controls.enabled = true;
    }
    if (isDragging) handleInputEnd();
    isCameraDragging = false;
    if (controls && (!e.touches || e.touches.length === 0)) controls.enabled = true;
  }

  // ---------- Mouse fallback ----------
  function onMouseDown(e) {
    if (window.PointerEvent) return;
    if (e.target && e.target.closest && e.target.closest('#ui-panel')) return;
    if (handleInputStart(e.clientX, e.clientY)) {
      if (controls) controls.enabled = false; e.preventDefault(); return;
    } else {
      isCameraDragging = true; prevX = e.clientX; prevY = e.clientY;
      if (controls) controls.enabled = false; e.preventDefault();
    }
  }
  function onMouseMove(e) {
    if (window.PointerEvent) return;
    if (isDragging && selectedObject) handleInputMove(e.clientX, e.clientY);
    else if (isCameraDragging) { const dx = e.clientX - prevX; const dy = e.clientY - prevY; manualCameraRotate(dx, dy); prevX = e.clientX; prevY = e.clientY; }
  }
  function onMouseUp(e) {
    if (window.PointerEvent) return;
    handleInputEnd();
    isCameraDragging = false;
    if (controls) controls.enabled = true;
  }

  // ---------------- Shapes & UI logic ----------------
  window.addShape = function(type) {
    let geometry, material;
    const color = 0x4dabf7;

    const matStandard = new THREE.MeshStandardMaterial({
      color: color, roughness: 0.4, metalness: 0.1,
      polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
    });

    let yPos = 0.5;

    if (type === 'cylinder') {
      geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
      material = [ matStandard.clone(), matStandard.clone(), matStandard.clone() ];
      yPos = 1;
    } else {
      if (type === 'cube') geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
      else if (type === 'sphere') { geometry = new THREE.SphereGeometry(0.8, 32, 32); yPos = 0.8; }
      else if (type === 'cone') { geometry = new THREE.ConeGeometry(0.8, 1.6, 32); yPos = 0.8; }
      material = matStandard;
    }

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set((Math.random()-0.5)*4, yPos, (Math.random()-0.5)*4);
    mesh.castShadow = true;
    mesh.userData = { isShape: true, type: type };

    // Do NOT add edges by default anymore (we'll add only when toggled)
    scene.add(mesh);
    selectObject(mesh);
  };

  // Edges utilities (only for selected)
  function addEdgesToMesh(mesh) {
    if (!mesh || !mesh.geometry) return;
    // Remove existing if present
    removeEdgesFromMesh(mesh);
    // Create subtle dark-gray edge lines
    const edgesGeom = new THREE.EdgesGeometry(mesh.geometry);
    const lineMat = new THREE.LineBasicMaterial({ color: 0x222222, transparent: true, opacity: 0.75, linewidth: 1 });
    const lines = new THREE.LineSegments(edgesGeom, lineMat);
    lines.name = 'selection-edge';
    // Add as child so it moves with the mesh
    mesh.add(lines);
  }
  function removeEdgesFromMesh(mesh) {
    if (!mesh) return;
    const existing = mesh.getObjectByName && mesh.getObjectByName('selection-edge');
    if (existing) {
      mesh.remove(existing);
      if (existing.geometry) existing.geometry.dispose();
      if (existing.material) existing.material.dispose();
    }
  }

  // Toggle edges state (UI)
  window.toggleEdges = function() {
    showEdgesEnabled = !showEdgesEnabled;
    const btn = document.getElementById('toggle-edges-btn');
    btn.innerText = showEdgesEnabled ? 'Hide Edges (Selected)' : 'Show Edges (Selected)';
    // Update selected shape edges
    if (selectedObject) {
      if (showEdgesEnabled) addEdgesToMesh(selectedObject);
      else removeEdgesFromMesh(selectedObject);
    }
  };

  // Apply RGB color to selected shape (affects full shape)
  // Apply RGB color to selected shape (affects full shape)
  window.applyRGB = function() {
    if (!selectedObject) return alert('Select a shape first.');
    const r = clampInt(document.getElementById('r-input').value, 0, 255);
    const g = clampInt(document.getElementById('g-input').value, 0, 255);
    const b = clampInt(document.getElementById('b-input').value, 0, 255);
    // convert to 0..1
    const rf = r / 255, gf = g / 255, bf = b / 255;
    const mat = selectedObject.material;
    if (Array.isArray(mat)) {
      mat.forEach(m => { if (m && m.color) m.color.setRGB(rf, gf, bf); });
    } else {
      if (mat && mat.color) mat.color.setRGB(rf, gf, bf);
    }
  };
  function clampInt(v, a, b) {
    let n = parseInt(v);
    if (isNaN(n)) n = a;
    return Math.max(a, Math.min(b, n));
  }

  // Wireframe / transparency / bases functions unchanged:
  window.toggleWireframe = function() {
    if(!selectedObject) return;
    const toggle = (m) => { m.wireframe = !m.wireframe; };
    const mat = selectedObject.material;
    if (Array.isArray(mat)) mat.forEach(toggle);
    else toggle(mat);
  };

  window.toggleTransparent = function() {
    if(!selectedObject) return;
    const toggle = (m) => {
      m.transparent = !m.transparent;
      m.opacity = m.transparent ? 0.3 : 1.0;
    };
    const mat = selectedObject.material;
    if (Array.isArray(mat)) mat.forEach(toggle);
    else toggle(mat);
  };

  window.toggleBases = function() {
    if(!selectedObject) return;
    if (Array.isArray(selectedObject.material) && selectedObject.userData.type === 'cylinder') {
      const top = selectedObject.material[1];
      const bot = selectedObject.material[2];
      const newColor = (top.color.getHex() === 0xffd700) ? 0x4dabf7 : 0xffd700;
      top.color.setHex(newColor);
      bot.color.setHex(newColor);
    } else {
      alert("Select a Cylinder first to highlight bases.");
    }
  };

  window.deleteSelected = function() {
    if (selectedObject) {
      // remove edges cleanup
      removeEdgesFromMesh(selectedObject);
      scene.remove(selectedObject);
      selectedObject = null;
      document.getElementById('delete-btn').innerText = "Delete";
    }
  };

  function selectObject(obj) {
    if (selectedObject && selectedObject !== obj) {
      setEmissive(selectedObject, 0x000000);
      // remove edges from old selection if showEdgesEnabled
      removeEdgesFromMesh(selectedObject);
    }
    selectedObject = obj;
    setEmissive(obj, 0x333333);
    document.getElementById('delete-btn').innerText = "Delete Selected";
    // Add edges for new selection if enabled
    if (showEdgesEnabled) addEdgesToMesh(selectedObject);
  }

  function setEmissive(obj, colorHex) {
    if (!obj || !obj.material) return;
    if (Array.isArray(obj.material)) {
      obj.material.forEach(m => { if (m && m.emissive) m.emissive.setHex(colorHex); });
    } else {
      if (obj.material.emissive) obj.material.emissive.setHex(colorHex);
    }
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);
    // update controls only if nothing else using gestures
    if (controls && !isDragging && !isCameraDragging && !isPointerPinching && !isTouchPinching) controls.update();
    renderer.render(scene, camera);
  }

})();
</script>

</body>
</html>